<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">

  <title>236376 OSE Lab 1: Booting a PC</title>
  <link rel="stylesheet" href="../labs.css" type="text/css">
  <script type="text/javascript" src="../labs.js">
</script>
  <style type="text/css">
p.c1 {font-weight: bold}
  </style>
  <style type="text/css">
span.c1 {font-weight: bold; text-decoration: underline}
  </style>
</head>

<body>
  <h1>236376 OSE Lab 1: Booting a PC</h1>

  <dl>
    <dt>Due date:</dt>

    <dd>Wednesday, March 23 2016 23:55</dd>

    <dt>TA in charge:</dt>

    <dd>Igor Smolyar <a href=
    "mailto:igors@cs.technion.ac.il?subject=OSE%202016,%20lab1">&lt;igors@cs.technion.ac.il&gt;</a></dd>
  </dl>

  <p><span class="c1">Please note</span>: You should <b>not</b>
  publish your lab solutions in any publicly accessible site such as
  github.</p>

  <h2>Lab Q&amp;A</h2>

  <p>We encourage you to ask questions on course's <a href=
  "https://piazza.com/technion.ac.il/spring2016/236376">Piazza
  Q&amp;A forum</a>. If no help provided on Piazza forum then try to
  email TA in charge. E-mails regarding this lab (such as
  administrative issues) should be sent with the subject "OSE 2016,
  lab1".</p>

  <h2>Introduction</h2>

  <p>This lab is split into three parts. The first part concentrates
  on getting familiarized with x86 assembly language, the QEMU x86
  emulator, and the PC's power-on bootstrap procedure. The second
  part examines the boot loader for our kernel, which resides in the
  <tt>boot</tt> directory of the <tt>lab</tt> tree. Finally, the
  third part delves into the initial template for our kernel itself,
  named JOS, which resides in the <tt>kernel</tt> directory.</p>

  <h3>Machine Setup</h3>Performing the labs require advanced software
  setup which is not directly available on faculty PC farm or at your
  home. In order to makes things simpler for everybody our working
  environment will consist of Linux running inside virtual machine
  (VM). Yes, at the end you will run your own OS inside emulator on
  top of Linux which runs under un a virtual machine on top of any
  other OS which runs on real hardware!

  <p><em>Note:</em> You can use physical machine instead of VM and
  skip the first step. If you're advanced Linux user and already
  running the required Linux (see below), you can even skip first two
  steps. However, do this on your own risk, we wouldn't be
  responsible if you suddenly loose all your data. (If you're
  hardcore Linux geek, you can substitute steps 1&amp;2 with chroot
  creation or substitute all three steps by manual installation of
  all the needed software)</p>

  <h4>Step 1. VM Setup</h4>Any decent virtual machine software will
  suit our needs. For example, free and open source <a href=
  "http://www.virtualbox.org/wiki/Downloads">VirtualBox</a>, or
  commercial-only VmWare Workstation. The later is installed on some
  PC farm stations and can be <a href=
  "https://csms.cs.technion.ac.il:4423/">obtained through CS
  faculty</a> at no charge. Create new VM for our Linux and ensure it
  has access to the Internet (we'll need it later).

  <h4>Step 2. Linux Installation</h4>Download <a href=
  "http://releases.ubuntu.com/14.04.2/ubuntu-14.04.2-desktop-i386.iso">
  Ubuntu <strong>14.04.2</strong> (Trusty Tahr) for
  <strong>i386</strong></a> and install it inside VM. Note, that
  other versions of Ubuntu, as well as other Linux distributions
  <strong>aren't suitable for us</strong> (Ubuntu 14.04.x is
  considered the same as 14.04). Feel free to install your favorite
  code editors or other software inside this "virtual" Ubuntu.

  <h4>Step 3. Additional Software Installation</h4>Login into your
  Ubuntu, open terminal and run (hereinafter <tt>$</tt> denotes a
  shell prompt):
  <pre>
$ <kbd>sudo apt-get -y install qemu gitk git-gui build-essential gcc-multilib</kbd>
[sudo] password for user: <kbd><em>&lt;enter your user password (not echoed to the terminal)&gt;</em></kbd>
&lt;lots of lines here&gt;
$ <kbd>sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</kbd>
$ <kbd>echo "set auto-load safe-path /" &gt;&gt; ~/.gdbinit</kbd>
Done!
</pre>In order to save you some typing you can open this page inside
VM (there is a Firefox browser installed by default) and copy-paste
long commands into the terminal (of course, you already know that
it's often sufficient to just select the text to copy it and press
middle button on the mouse to paste it, no need to press
<kbd>Ctrl-C</kbd>/<kbd>Ctrl-V</kbd>).

  <h3>Source Code Setup</h3>

  <p>The files you will need for this and subsequent lab assignments
  in this course are distributed using the <a href=
  "http://git-scm.com/">Git</a> version control system. To learn more
  about Git, take a look at the <a href=
  "http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git
  user's manual</a>, or, if you are already familiar with other
  version control systems, you may find this <a href=
  "http://eagain.net/articles/git-for-computer-scientists/">CS-oriented
  overview of Git</a> useful.</p>

  <p>The URL for the course Git repository is <a href=
  "http://www.cs.technion.ac.il/~cs236376/jos.git">http://www.cs.technion.ac.il/~cs236376/jos.git</a>.
  To install the files in your machine, you need to <em>clone</em>
  the course repository, by running the commands below.</p>
  <pre>
$ <kbd>git clone http://www.cs.technion.ac.il/~cs236376/jos.git lab</kbd>
Initialized empty Git repository in /home/user/lab/.git/
$ <kbd>cd lab</kbd>
$ 
</pre>

  <p>Git allows you to keep track of the changes you make to the
  code. For example, if you are finished with one of the exercises,
  and want to checkpoint your progress, you can <em>commit</em> your
  changes by running:</p>
  <pre>
$ <kbd>git commit -am 'my solution for lab1 exercise9'</kbd>
Created commit 60d2135: my solution for lab1 exercise9
 1 files changed, 1 insertions(+), 0 deletions(-)
$
</pre>

  <p>Git is a distributed version control system, unlike SVN or CVS,
  which means all your commits will be done to a local copy of the
  repository and are only saved on your own computer.</p>

  <p>You can keep track of your changes by using the <kbd>git
  diff</kbd> command. Running <kbd>git diff</kbd> will display the
  changes to your code since your last commit, and <kbd>git diff
  origin/lab1</kbd> will display the changes relative to the initial
  code supplied for this lab. Here, <tt>origin/lab1</tt> is the name
  of the git branch with the initial code you downloaded from our
  server for this assignment.</p>

  <h3>Questionary</h3>

  <p>In addition to writing few lines of code, you need to answer
  several questions throughout the lab. A <a href=
  "lab1-questionary.txt">textual template</a> called
  <tt>lab1-questionary.txt</tt> contains the required questions
  formulated in easy to check manner. Download it to lab1 source
  directory (the one containing <tt>.git</tt> subdirectory) and open
  in your favorite text editor while you continue to read this lab
  description. Whenever you see a question/exercise here, refer to
  <tt>lab1-questionary.txt</tt> to fill the answer. Some questions
  appearing here are for self-check and don't require answer
  submission (so they are absent from
  <tt>lab1-questionary.txt</tt>).</p>

  <p>The challenge for this lab is completely optional and will not
  be checked.</p>

  <h3 id="handin">Hand-In (Submission) Procedure</h3>

  <p>When you are ready to hand in your lab (including the filled
  <tt>lab1-questionary.txt</tt>), run <kbd>make handin</kbd> in the
  source directory. This will make a tar file for you, which you can
  then submit via <a href=
  "http://webcourse.cs.technion.ac.il/236376/">webcourse site</a>.
  You can list the contents of the tar file with <kbd>tar -tvzf
  lab1-handin.tar.gz</kbd> or unpack it (in another directory) with
  <kbd>tar -xzf lab1-handin.tar.gz</kbd>.</p>

  <p>We will be grading your solutions with a grading program. You
  can run <kbd>make grade</kbd> to test your code with the grading
  program (no test for the questionary is provided).</p>

  <h2>Part 1: PC Bootstrap</h2>The purpose of the first exercise is
  to introduce you to x86 assembly language and the PC bootstrap
  process, and to get you started with QEMU and QEMU/GDB debugging.
  You will not have to write any code for this part of the lab, but
  you should go through it anyway for your own understanding and be
  prepared to answer the questions posed below.

  <h3>Getting Started with x86 assembly</h3>

  <p>If you are not already familiar with x86 assembly language, you
  will quickly become familiar with it during this course! The
  <a href="../../readings/pcasm-book.pdf">PC Assembly Language
  Book</a> is an excellent place to start. Hopefully, the book
  contains mixture of new and old material for you.</p>

  <p><em>Warning:</em> Unfortunately the examples in the book are
  written for the NASM assembler, whereas we will be using the GNU
  assembler. NASM uses the so-called <em>Intel</em> syntax while GNU
  uses the <em>AT&amp;T</em> syntax. While semantically equivalent,
  an assembly file will differ quite a lot, at least superficially,
  depending on which syntax is used. Luckily the conversion between
  the two is pretty simple, and is covered in <a href=
  "http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">
  Brennan's Guide to Inline Assembly</a>.</p>

  <div class="required">
    <p><span class="header">Exercise 1.</span> Familiarize yourself
    with the assembly language materials available on <a href=
    "../../reference.html">the course reference page</a>. You don't
    have to read them now, but you'll almost certainly want to refer
    to some of this material when reading and writing x86
    assembly.</p>

    <p>We do recommend reading the section "The Syntax" in <a href=
    "http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">
    Brennan's Guide to Inline Assembly</a>. It gives a good (and
    quite brief) description of the AT&amp;T assembly syntax we'll be
    using with the GNU assembler in JOS.</p>
  </div>

  <p>Certainly the definitive reference for x86 assembly language
  programming is Intel's instruction set architecture reference,
  which you can find on <a href="../../reference.html">the course
  reference page</a> in two flavors: an HTML edition of the old
  <a href="../../readings/i386/toc.htm">80386 Programmer's Reference
  Manual</a>, which is much shorter and easier to navigate than more
  recent manuals but describes all of the x86 processor features that
  we will make use of in the course; and the full, latest and
  greatest <a href=
  "http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">
  IA-32 Intel Architecture Software Developer's Manuals</a> from
  Intel, covering all the features of the most recent processors that
  we won't need in class but you may be interested in learning about.
  An equivalent (and often friendlier) set of manuals is <a href=
  "http://developer.amd.com/documentation/guides/Pages/default.aspx#manuals">
  available from AMD</a>. Save the Intel/AMD architecture manuals for
  later or use them for reference when you want to look up the
  definitive explanation of a particular processor feature or
  instruction.</p>

  <h3>Simulating the x86</h3>

  <p>Instead of developing the operating system on a real, physical
  personal computer (PC), we use a program that faithfully emulates a
  complete PC: the code you write for the emulator will boot on a
  real PC too. Using an emulator simplifies debugging; you can, for
  example, set break points inside of the emulated x86, which is
  difficult to do with the silicon version of an x86.</p>

  <p>In the course we will use the <a href=
  "http://www.qemu.org/">QEMU Emulator</a>, a modern and relatively
  fast emulator. While QEMU's built-in monitor provides only limited
  debugging support, QEMU can act as a remote debugging target for
  the <a href="http://www.gnu.org/software/gdb/">GNU debugger</a>
  (GDB), which we'll use in this lab to step through the early boot
  process.</p>

  <p>To get started, extract the Lab 1 files as described above in
  "Software Setup", then type <kbd>make</kbd> in the <samp>lab</samp>
  directory to build the minimal boot loader and kernel you will
  start with. (It's a little generous to call the code we're running
  here a "kernel," but we'll flesh it out throughout the
  semester.)</p>
  <pre>
$ <kbd>cd lab</kbd>
$ <kbd>make</kbd>
+ as kern/entry.S
+ cc kern/init.c
+ cc kern/console.c
+ cc kern/monitor.c
+ cc kern/printf.c
+ cc lib/printfmt.c
+ cc lib/readline.c
+ cc lib/string.c
+ ld obj/kern/kernel
+ as boot/boot.S
+ cc -Os boot/main.c
+ ld boot/boot
boot block is 399 bytes (max 510)
+ mk obj/kern/kernel.img
</pre>

  <p>Now you're ready to run QEMU, supplying the file
  <samp>obj/kern/kernel.img</samp>, created above, as the contents of
  the emulated PC's "virtual hard disk." This hard disk image
  contains both our boot loader (<samp>obj/boot/boot</samp>) and our
  kernel (<samp>obj/kernel</samp>).</p>
  <pre>
$ <kbd>make qemu</kbd>
</pre>

  <p>This executes QEMU with the options required to set the hard
  disk and direct serial port output to the terminal. Some text
  should appear in the QEMU window:</p>
  <pre>
Booting from Hard Disk...
6828 decimal is XXX octal!
entering test_backtrace 5
entering test_backtrace 4
entering test_backtrace 3
entering test_backtrace 2
entering test_backtrace 1
entering test_backtrace 0
leaving test_backtrace 0
leaving test_backtrace 1
leaving test_backtrace 2
leaving test_backtrace 3
leaving test_backtrace 4
leaving test_backtrace 5
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
K&gt;
</pre>

  <p>Everything after '<samp>Booting from Hard Disk...</samp>' was
  printed by our skeletal JOS kernel; the <samp>K&gt;</samp> is the
  prompt printed by the small <em>monitor</em>, or interactive
  control program, that we've included in the kernel. These lines
  printed by the kernel will also appear in the regular shell window
  from which you ran QEMU. This is because for testing and lab
  grading purposes we have set up the JOS kernel to write its console
  output not only to the virtual VGA display (as seen in the QEMU
  window), but also to the simulated PC's virtual serial port, which
  QEMU in turn outputs to its own standard output. Likewise, the JOS
  kernel will take input from both the keyboard and the serial port,
  so you can give it commands in either the VGA display window or the
  terminal running QEMU. Alternatively, you can use the serial
  console without the virtual VGA by running <kbd>make
  qemu-nox</kbd>.</p>

  <p>There are only two commands you can give to the kernel monitor,
  <samp>help</samp> and <samp>kerninfo</samp>.</p>
  <pre>
K&gt; <kbd>help</kbd>
help - display this list of commands
kerninfo - display information about the kernel
K&gt; <kbd>kerninfo</kbd>
Special kernel symbols:
  entry  f010000c (virt)  0010000c (phys)
  etext  f0101a75 (virt)  00101a75 (phys)
  edata  f0112300 (virt)  00112300 (phys)
  end    f0112960 (virt)  00112960 (phys)
Kernel executable memory footprint: 75KB
K&gt;
</pre>

  <p>The <samp>help</samp> command is obvious, and we will shortly
  discuss the meaning of what the <samp>kerninfo</samp> command
  prints. Although simple, it's important to note that this kernel
  monitor is running "directly" on the "raw (virtual) hardware" of
  the simulated PC. This means that you should be able to copy the
  contents of <samp>obj/kern/kernel.img</samp> onto the first few
  sectors of a <em>real</em> hard disk, insert that hard disk into a
  real PC, turn it on, and see exactly the same thing on the PC's
  real screen as you did above in the QEMU window. (We don't
  recommend you do this on a real machine with useful information on
  its hard disk, though, because copying <samp>kernel.img</samp> onto
  the beginning of its hard disk will trash the master boot record
  and the beginning of the first partition, effectively causing
  everything previously on the hard disk to be lost!)</p>

  <h3>The PC's Physical Address Space</h3>

  <p>We will now dive into a bit more detail about how a PC starts
  up. A PC's physical address space is hard-wired to have the
  following general layout:</p>

  <table align="center">
    <tr>
      <td>
        <pre>
+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</pre>
      </td>
    </tr>
  </table>

  <p>The first PCs, which were based on the 16-bit Intel 8088
  processor, were only capable of addressing 1MB of physical memory.
  The physical address space of an early PC would therefore start at
  0x00000000 but end at 0x000FFFFF instead of 0xFFFFFFFF. The 640KB
  area marked "Low Memory" was the <em>only</em> random-access memory
  (RAM) that an early PC could use; in fact the very earliest PCs
  only could be configured with 16KB, 32KB, or 64KB of RAM!</p>

  <p>The 384KB area from 0x000A0000 through 0x000FFFFF was reserved
  by the hardware for special uses such as video display buffers and
  firmware held in non-volatile memory. The most important part of
  this reserved area is the Basic Input/Output System (BIOS), which
  occupies the 64KB region from 0x000F0000 through 0x000FFFFF. In
  early PCs the BIOS was held in true read-only memory (ROM), but
  current PCs store the BIOS in updateable flash memory. The BIOS is
  responsible for performing basic system initialization such as
  activating the video card and checking the amount of memory
  installed. After performing this initialization, the BIOS loads the
  operating system from some appropriate location such as floppy
  disk, hard disk, CD-ROM, or the network, and passes control of the
  machine to the operating system.</p>

  <p>When Intel finally "broke the one megabyte barrier" with the
  80286 and 80386 processors, which supported 16MB and 4GB physical
  address spaces respectively, the PC architects nevertheless
  preserved the original layout for the low 1MB of physical address
  space in order to ensure backward compatibility with existing
  software. Modern PCs therefore have a "hole" in physical memory
  from 0x000A0000 to 0x00100000, dividing RAM into "low" or
  "conventional memory" (the first 640KB) and "extended memory"
  (everything else). In addition, some space at the very top of the
  PC's 32-bit physical address space, above all physical RAM, is now
  commonly reserved by the BIOS for use by 32-bit PCI devices.</p>

  <p>Recent x86 processors can support <em>more</em> than 4GB of
  physical RAM, so RAM can extend further above 0xFFFFFFFF. In this
  case the BIOS must arrange to leave a <em>second</em> hole in the
  system's RAM at the top of the 32-bit addressable region, to leave
  room for these 32-bit devices to be mapped. Because of design
  limitations JOS will use only the first 256MB of a PC's physical
  memory anyway, so for now we will pretend that all PCs have "only"
  a 32-bit physical address space. But dealing with complicated
  physical address spaces and other aspects of hardware organization
  that evolved over many years is one of the important practical
  challenges of OS development.</p>

  <h3>The ROM BIOS</h3>

  <p>In this portion of the lab, you'll use QEMU's debugging
  facilities to investigate how an IA-32 compatible computer
  boots.</p>

  <p>Open two terminal windows. In one, enter <kbd>make
  qemu-gdb</kbd> (or <kbd>make qemu-nox-gdb</kbd>). This starts up
  QEMU, but QEMU stops just before the processor executes the first
  instruction and waits for a debugging connection from GDB. In the
  second terminal, from the same directory you ran <samp>make</samp>,
  run <kbd>gdb</kbd>. You should see something like this,</p>
  <pre>
$ <kbd>gdb</kbd>
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.htmll&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this
configuration of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb)
</pre>

  <p>We provided a <samp>.gdbinit</samp> file that set up GDB to
  debug the 16-bit code used during early boot and directed it to
  attach to the listening QEMU.</p>

  <p>The following line:</p>
  <pre>
[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b
</pre>

  <p>is GDB's disassembly of the first instruction to be executed.
  From this output you can conclude a few things:</p>

  <ul>
    <li>The IBM PC starts executing at physical address 0x000ffff0,
    which is at the very top of the 64KB area reserved for the ROM
    BIOS.</li>

    <li>The PC starts executing with <samp>CS = 0xf000</samp> and
    <samp>IP = 0xfff0</samp>.</li>

    <li>The first instruction to be executed is a <samp>jmp</samp>
    instruction, which jumps to the segmented address <samp>CS =
    0xf000</samp> and <samp>IP = 0xe05b</samp>.</li>
  </ul>

  <p>Why does QEMU start like this? This is how Intel designed the
  8088 processor, which IBM used in their original PC. Because the
  BIOS in a PC is "hard-wired" to the physical address range
  0x000f0000-0x000fffff, this design ensures that the BIOS always
  gets control of the machine first after power-up or any system
  restart - which is crucial because on power-up there <em>is</em> no
  other software anywhere in the machine's RAM that the processor
  could execute. The QEMU emulator comes with its own BIOS, which it
  places at this location in the processor's simulated physical
  address space. On processor reset, the (simulated) processor enters
  real mode and sets CS to 0xf000 and the IP to 0xfff0, so that
  execution begins at that (CS:IP) segment address. How does the
  segmented address 0xf000:fff0 turn into a physical address?</p>

  <p>To answer that we need to know a bit about real mode addressing.
  In real mode (the mode that PC starts off in), address translation
  works according to the formula: <em>physical address</em> = 16 *
  <em>segment</em> + <em>offset</em>. So, when the PC sets CS to
  0xf000 and IP to 0xfff0, the physical address referenced is:</p>
  <pre>
   16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is
   = 0xf0000 + 0xfff0     # easy--just append a 0.
   = 0xffff0 
</pre>

  <p><samp>0xffff0</samp> is 16 bytes before the end of the BIOS
  (<samp>0x100000</samp>). Therefore we shouldn't be surprised that
  the first thing that the BIOS does is <samp>jmp</samp> backwards to
  an earlier location in the BIOS; after all how much could it
  accomplish in just 16 bytes?</p>

  <div class="required">
    <p><span class="header">Exercise 2.</span> Use GDB's
    <kbd>si</kbd> (Step Instruction) command to trace into the ROM
    BIOS for a few more instructions, and try to guess what it might
    be doing. You might want to look at <a href=
    "http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">
    Phil Storrs I/O Ports Description</a>, as well as other materials
    on the <a href="../../reference.html">course reference materials
    page</a>. No need to figure out all the details - just the
    general idea of what the BIOS is doing first.</p>
  </div>

  <p>When the BIOS runs, it sets up an interrupt descriptor table and
  initializes various devices such as the VGA display. This is where
  the "<samp>Starting SeaBIOS</samp>" message you see in the QEMU
  window comes from.</p>

  <p>After initializing the PCI bus and all the important devices the
  BIOS knows about, it searches for a bootable device such as a
  floppy, hard drive, or CD-ROM. Eventually, when it finds a bootable
  disk, the BIOS reads the <em>boot loader</em> from the disk and
  transfers control to it.</p>

  <h2>Part 2: The Boot Loader</h2>

  <p>Floppy and hard disks for PCs are divided into 512 byte regions
  called <em>sectors</em>. A sector is the disk's minimum transfer
  granularity: each read or write operation must be one or more
  sectors in size and aligned on a sector boundary. If the disk is
  bootable, the first sector is called the <em>boot sector</em>,
  since this is where the boot loader code resides. When the BIOS
  finds a bootable floppy or hard disk, it loads the 512-byte boot
  sector into memory at physical addresses 0x7c00 through 0x7dff, and
  then uses a <samp>jmp</samp> instruction to set the CS:IP to
  <samp>0000:7c00</samp>, passing control to the boot loader. Like
  the BIOS load address, these addresses are fairly arbitrary - but
  they are fixed and standardized for PCs.</p>

  <p>The ability to boot from a CD-ROM came much later during the
  evolution of the PC, and as a result the PC architects took the
  opportunity to rethink the boot process slightly. As a result, the
  way a modern BIOS boots from a CD-ROM is a bit more complicated
  (and more powerful). CD-ROMs use a sector size of 2048 bytes
  instead of 512, and the BIOS can load a much larger boot image from
  the disk into memory (not just one sector) before transferring
  control to it. For more information, see the <a href=
  "../../readings/boot-cdrom.pdf">"El Torito" Bootable CD-ROM Format
  Specification</a>.</p>

  <p>For this course, however, we will use the conventional hard
  drive boot mechanism, which means that our boot loader must fit
  into a measly 512 bytes. The boot loader consists of one assembly
  language source file, <samp>boot/boot.S</samp>, and one C source
  file, <samp>boot/main.c</samp> Look through these source files
  carefully and make sure you understand what's going on. The boot
  loader must perform two main functions:</p>

  <ol>
    <li>First, the boot loader switches the processor from real mode
    to <em>32-bit protected mode</em>, because it is only in this
    mode that software can access all the memory above 1MB in the
    processor's physical address space. Protected mode is described
    briefly in sections 1.2.7 and 1.2.8 of <a href=
    "../../readings/pcasm-book.pdf">PC Assembly Language</a>, and in
    great detail in the Intel architecture manuals. At this point you
    only have to understand that translation of segmented addresses
    (segment:offset pairs) into physical addresses happens
    differently in protected mode, and that after the transition
    offsets are 32 bits instead of 16.</li>

    <li>Second, the boot loader reads the kernel from the hard disk
    by directly accessing the IDE disk device registers via the x86's
    special I/O instructions. If you would like to understand better
    what the particular I/O instructions here mean, check out the
    "IDE hard drive controller" section on <a href=
    "../../reference.html">the course reference page</a>. You will
    not need to learn much about programming specific devices in this
    class: writing device drivers is in practice a very important
    part of OS development, but from a conceptual or architectural
    viewpoint it is also one of the least interesting.</li>
  </ol>

  <p>After you understand the boot loader source code, look at the
  file <samp>obj/boot/boot.asm</samp>. This file is a disassembly of
  the boot loader that our GNUmakefile creates <em>after</em>
  compiling the boot loader. This disassembly file makes it easy to
  see exactly where in physical memory all of the boot loader's code
  resides, and makes it easier to track what's happening while
  stepping through the boot loader in GDB. Likewise,
  <samp>obj/kern/kernel.asm</samp> contains a disassembly of the JOS
  kernel, which can often be useful for debugging.</p>

  <p>You can set address breakpoints in GDB with the <samp>b</samp>
  command. For example, <kbd>b *0x7c00</kbd> sets a breakpoint at
  address 0x7C00. Once at a breakpoint, you can continue execution
  using the <kbd>c</kbd> and <kbd>si</kbd> commands: <kbd>c</kbd>
  causes QEMU to continue execution until the next breakpoint (or
  until you press <kbd>Ctrl-C</kbd> in GDB), and <kbd>si
  <em>N</em></kbd> steps through the instructions
  <em><samp>N</samp></em> at a time.</p>

  <p>To examine instructions in memory (besides the immediate next
  one to be executed, which GDB prints automatically), you use the
  <kbd>x/i</kbd> command. This command has the syntax
  <kbd>x/<em>N</em>i <em>ADDR</em></kbd>, where <em>N</em> is the
  number of consecutive instructions to disassemble and <em>ADDR</em>
  is the memory address at which to start disassembling.</p>

  <div class="required">
    <p><span class="header">Exercise 3.</span> Take a look at the
    <a href="../../labguide.html">lab tools guide</a>, especially the
    section on GDB commands. Even if you're familiar with GDB, this
    includes some esoteric GDB commands that are useful for OS
    work.</p>

    <p>Set a breakpoint at address 0x7c00, which is where the boot
    sector will be loaded. Continue execution until that breakpoint.
    Trace through the code in <samp>boot/boot.S</samp>, using the
    source code and the disassembly file
    <samp>obj/boot/boot.asm</samp> to keep track of where you are.
    Also use the <samp>x/i</samp> command in GDB to disassemble
    sequences of instructions in the boot loader, and compare the
    original boot loader source code with both the disassembly in
    <samp>obj/boot/boot.asm</samp> and GDB.</p>

    <p>Trace into <samp>bootmain()</samp> in
    <samp>boot/main.c</samp>, and then into <samp>readsect()</samp>.
    Identify the exact assembly instructions that correspond to each
    of the statements in <samp>readsect()</samp>. Trace through the
    rest of <samp>readsect()</samp> and back out into
    <samp>bootmain()</samp>, and identify the begin and end of the
    <samp>for</samp> loop that reads the remaining sectors of the
    kernel from the disk. Find out what code will run when the loop
    is finished, set a breakpoint there, and continue to that
    breakpoint. Then step through the remainder of the boot
    loader.</p>
  </div>

  <p>Be able to answer the following questions:</p>

  <ul>
    <li>At what point does the processor start executing 32-bit code?
    What exactly causes the switch from 16- to 32-bit mode?</li>

    <li>What is the <em>last</em> instruction of the boot loader
    executed, and what is the <em>first</em> instruction of the
    kernel it just loaded?</li>

    <li><em>Where</em> is the first instruction of the kernel?</li>

    <li>How does the boot loader decide how many sectors it must read
    in order to fetch the entire kernel from disk? Where does it find
    this information?</li>
  </ul>

  <h3>Loading the Kernel</h3>

  <p>We will now look in further detail at the C language portion of
  the boot loader, in <samp>boot/main.c</samp>. But before doing so,
  this is a good time to stop and review some of the basics of C
  programming.</p>

  <div class="required">
    <p><span class="header">Exercise 4.</span> Read about programming
    with pointers in C. The best reference for the C language is
    <em>The C Programming Language</em> by Brian Kernighan and Dennis
    Ritchie (known as 'K&amp;R'). Technion library has <a href=
    "http://aleph.technion.ac.il/F/?func=item-global&amp;doc_library=TEC01&amp;doc_number=002053482">
    a lot of copies</a>.</p>

    <p>Read 5.1 (Pointers and Addresses) through 5.5 (Character
    Pointers and Functions) in K&amp;R. Then download the code for
    <a href="./pointers.c">pointers.c</a>, run it, and make sure you
    understand where all of the printed values come from. In
    particular, make sure you understand where the pointer addresses
    in lines 1 and 6 come from, how all the values in lines 2 through
    4 get there, and why the values printed in line 5 are seemingly
    corrupted.</p>

    <p>There are other references on pointers in C, though not as
    strongly recommended. <a href="../../readings/pointers.pdf">A
    tutorial by Ted Jensen</a> that cites K&amp;R heavily is
    available in the course readings.</p>

    <p><em>Warning:</em> Unless you are already thoroughly versed in
    C, do not skip or even skim this reading exercise. If you do not
    really understand pointers in C, you will suffer untold pain and
    misery in subsequent labs, and then eventually come to understand
    them the hard way. Trust us; you don't want to find out what "the
    hard way" is.</p>
  </div>

  <p>To make sense out of <samp>boot/main.c</samp> you'll need to
  know what an ELF binary is. When you compile and link a C program
  such as the JOS kernel, the compiler transforms each C source
  ('<samp>.c</samp>') file into an <em>object</em>
  ('<samp>.o</samp>') file containing assembly language instructions
  encoded in the binary format expected by the hardware. The linker
  then combines all of the compiled object files into a single
  <em>binary image</em> such as <samp>obj/kern/kernel</samp>, which
  in this case is a binary in the ELF format, which stands for
  "Executable and Linkable Format".</p>

  <p>Full information about this format is available in <a href=
  "../../readings/elf.pdf">the ELF specification</a> on <a href=
  "../../reference.html">our reference page</a>, but you will not
  need to delve very deeply into the details of this format in this
  class. Although as a whole the format is quite powerful and
  complex, most of the complex parts are for supporting dynamic
  loading of shared libraries, which we will not do in this
  class.</p>

  <p>For the purposes of the course, you can consider an ELF
  executable to be a header with loading information, followed by
  several <em>program sections</em>, each of which is a contiguous
  chunk of code or data intended to be loaded into memory at a
  specified address. The boot loader does not modify the code or
  data; it loads it into memory and starts executing it.</p>

  <p>An ELF binary starts with a fixed-length <em>ELF header</em>,
  followed by a variable-length <em>program header</em> listing each
  of the program sections to be loaded. The C definitions for these
  ELF headers are in <samp>inc/elf.h</samp>. The program sections
  we're interested in are:</p>

  <ul>
    <li><samp>.text</samp>: The program's executable
    instructions.</li>

    <li><samp>.rodata</samp>: Read-only data, such as ASCII string
    constants produced by the C compiler. (We will not bother setting
    up the hardware to prohibit writing, however.)</li>

    <li><samp>.data</samp>: The data section holds the program's
    initialized data, such as global variables declared with
    initializers like <samp>int x = 5;</samp>.</li>
  </ul>

  <p>When the linker computes the memory layout of a program, it
  reserves space for <em>uninitialized</em> global variables, such as
  <samp>int x;</samp>, in a section called <samp>.bss</samp> that
  immediately follows <samp>.data</samp> in memory. C requires that
  "uninitialized" global variables start with a value of zero. Thus
  there is no need to store contents for <samp>.bss</samp> in the ELF
  binary; instead, the linker records just the address and size of
  the <samp>.bss</samp> section. The loader or the program itself
  must arrange to zero the <samp>.bss</samp> section.</p>

  <p>Examine the full list of the names, sizes, and link addresses of
  all the sections in the kernel executable by typing:</p>
  <pre>
$ <kbd>objdump -h obj/kern/kernel</kbd>
</pre>

  <p>You will see many more sections than the ones we listed above,
  but the others are not important for our purposes. Most of the
  others are to hold debugging information, which is typically
  included in the program's executable file but not loaded into
  memory by the program loader.</p>

  <p>Take particular note of the "VMA" (or <em>link address</em>) and
  the "LMA" (or <em>load address</em>) of the <samp>.text</samp>
  section. The load address of a section is the memory address at
  which that section should be loaded into memory. In the ELF object,
  this is stored in the <code>ph-&gt;p_pa</code> field (in this case,
  it really is a physical address, though the ELF specification is
  vague on the actual meaning of this field).</p>

  <p>The link address of a section is the memory address from which
  the section expects to execute. The linker encodes the link address
  in the binary in various ways, such as when the code needs the
  address of a global variable, with the result that a binary usually
  won't work if it is executing from an address that it is not linked
  for. (It is possible to generate <em>position-independent</em> code
  that does not contain any such absolute addresses. This is used
  extensively by modern shared libraries, but it has performance and
  complexity costs, so we won't be using it in the course.)</p>

  <p>Typically, the link and load addresses are the same. For
  example, look at the <samp>.text</samp> section of the boot
  loader:</p>
  <pre>
$ <kbd>objdump -h obj/boot/boot.out</kbd>
</pre>

  <p>The BIOS loads the boot sector into memory starting at address
  0x7c00, so this is the boot sector's load address. This is also
  where the boot sector executes from, so this is also its link
  address. We set the link address by passing <samp>-Ttext
  0x7C00</samp> to the linker in <samp>boot/Makefrag</samp>, so the
  linker will produce the correct memory addresses in the generated
  code.</p>

  <div class="required">
    <p><span class="header">Exercise 5.</span> Trace through the
    first few instructions of the boot loader again and identify the
    first instruction that would "break" or otherwise do the wrong
    thing if you were to get the boot loader's link address wrong.
    Then change the link address in <samp>boot/Makefrag</samp> to
    something wrong, run <kbd>make clean</kbd>, recompile the lab
    with <kbd>make</kbd>, and trace into the boot loader again to see
    what happens. Don't forget to change the link address back and
    <kbd>make clean</kbd> again afterward!</p>
  </div>

  <p>Look back at the load and link addresses for the kernel. Unlike
  the boot loader, these two addresses aren't the same: the kernel is
  telling the boot loader to load it into memory at a low address (1
  megabyte), but it expects to execute from a high address. We'll dig
  in to how we make this work in the next section.</p>

  <p>Besides the section information, there is one more field in the
  ELF header that is important to us, named <samp>e_entry</samp>.
  This field holds the link address of the <em>entry point</em> in
  the program: the memory address in the program's text section at
  which the program should begin executing. You can see the entry
  point:</p>
  <pre>
$ <kbd>objdump -f obj/kern/kernel</kbd>
</pre>

  <p>You should now be able to understand the minimal ELF loader in
  <samp>boot/main.c</samp>. It reads each section of the kernel from
  disk into memory at the section's load address and then jumps to
  the kernel's entry point.</p>

  <div class="required">
    <p><span class="header">Exercise 6.</span> We can examine memory
    using GDB's <kbd>x</kbd> command. The <a href=
    "https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html#Memory">
    GDB manual</a> has full details, but for now, it is enough to
    know that the command <kbd>x/<em>N</em>x <em>ADDR</em></kbd>
    prints <em><samp>N</samp></em> words of memory at
    <em><samp>ADDR</samp></em>. (Note that both '<samp>x</samp>'s in
    the command are lowercase.) <em>Warning</em>: The size of a word
    is not a universal standard. In GNU assembly, a word is two bytes
    (the 'w' in xorw, which stands for word, means 2 bytes).</p>

    <p>Reset the machine (exit QEMU/GDB and start them again).
    Examine the 8 words of memory at 0x00100000 at the point the BIOS
    enters the boot loader, and then again at the point the boot
    loader enters the kernel. Why are they different? What is there
    at the second breakpoint? (You do not really need to use QEMU to
    answer this question. Just think.)</p>
  </div>

  <h2>Part 3: The Kernel</h2>

  <p>We will now start to examine the minimal JOS kernel in a bit
  more detail. (And you will finally get to write some code!). Like
  the boot loader, the kernel begins with some assembly language code
  that sets things up so that C language code can execute
  properly.</p>

  <h3>Using virtual memory to work around position dependence</h3>

  <p>When you inspected the boot loader's link and load addresses
  above, they matched perfectly, but there was a (rather large)
  disparity between the <em>kernel's</em> link address (as printed by
  objdump) and its load address. Go back and check both and make sure
  you can see what we're talking about. (Linking the kernel is more
  complicated than the boot loader, so the link and load addresses
  are at the top of <samp>kern/kernel.ld</samp>.)</p>

  <p>Operating system kernels often like to be linked and run at very
  high <em>virtual address</em>, such as 0xf0100000, in order to
  leave the lower part of the processor's virtual address space for
  user programs to use. The reason for this arrangement will become
  clearer in the next lab.</p>

  <p>Many machines don't have any physical memory at address
  0xf0100000, so we can't count on being able to store the kernel
  there. Instead, we will use the processor's memory management
  hardware to map virtual address 0xf0100000 (the link address at
  which the kernel code <em>expects</em> to run) to physical address
  0x00100000 (where the boot loader loaded the kernel into physical
  memory). This way, although the kernel's virtual address is high
  enough to leave plenty of address space for user processes, it will
  be loaded in physical memory at the 1MB point in the PC's RAM, just
  above the BIOS ROM. This approach requires that the PC have at
  least a few megabytes of physical memory (so that physical address
  0x00100000 works), but this is likely to be true of any PC built
  after about 1990.</p>

  <p>In fact, in the next lab, we will map the <em>entire</em> bottom
  256MB of the PC's physical address space, from physical addresses
  0x00000000 through 0x0fffffff, to virtual addresses 0xf0000000
  through 0xffffffff respectively. You should now see why JOS can
  only use the first 256MB of physical memory.</p>

  <p>For now, we'll just map the first 4MB of physical memory, which
  will be enough to get us up and running. We do this using the
  hand-written, statically-initialized page directory and page table
  in <samp>kern/entrypgdir.c</samp>. For now, you don't have to
  understand the details of how this works, just the effect that it
  accomplishes. Up until <samp>kern/entry.S</samp> sets the
  <code>CR0_PG</code> flag, memory references are treated as physical
  addresses (strictly speaking, they're linear addresses, but
  boot/boot.S set up an identity mapping from linear addresses to
  physical addresses and we're never going to change that). Once
  <code>CR0_PG</code> is set, memory references are virtual addresses
  that get translated by the virtual memory hardware to physical
  addresses. <code>entry_pgdir</code> translates virtual addresses in
  the range 0xf0000000 through 0xf0400000 to physical addresses
  0x00000000 through 0x00400000, as well as virtual addresses
  0x00000000 through 0x00400000 to physical addresses 0x00000000
  through 0x00400000. Any virtual address that is not in one of these
  two ranges will cause a hardware interrupt (called a page fault)
  which aren't able to handle just yet.</p>

  <div class="required">
    <p><span class="header">Exercise 7.</span> Use QEMU and GDB to
    trace into the JOS kernel and stop at the <code>movl %eax,
    %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now,
    single step over that instruction using the <kbd>stepi</kbd> GDB
    command. Again, examine memory at 0x00100000 and at 0xf0100000.
    Make sure you understand what just happened.</p>

    <p>What is the first instruction <em>after</em> the new mapping
    is established that would fail to work properly if the mapping
    weren't in place? Comment out the <code>movl %eax, %cr0</code> in
    <samp>kern/entry.S</samp>, trace into it, and see if you were
    right.</p>
  </div>

  <h3>Formatted Printing to the Console</h3>

  <p>Most people take functions like <samp>printf()</samp> for
  granted, sometimes even thinking of them as "primitives" of the C
  language. But in an OS kernel, we have to implement all I/O
  ourselves.</p>

  <p>Read through <samp>kern/printf.c</samp>,
  <samp>lib/printfmt.c</samp>, and <samp>kern/console.c</samp>, and
  make sure you understand their relationship. It will become clear
  in later labs why <samp>printfmt.c</samp> is located in the
  separate <samp>lib</samp> directory.</p>

  <div class="required">
    <p><span class="header">Exercise 8.</span> We have omitted a
    small fragment of code - the code necessary to print octal
    numbers using patterns of the form "%o". Find and fill in this
    code fragment.</p>
  </div>

  <p>Be able to answer the following questions:</p>

  <ol>
    <li>Explain the interface between <samp>printf.c</samp> and
    <samp>console.c</samp>. Specifically, what function does
    <samp>console.c</samp> export? How is this function used by
    <samp>printf.c</samp>?</li>

    <li>Explain the following from <samp>console.c</samp>:
      <pre>
1      if (crt_pos &gt;= CRT_SIZE) {
2              int i;
3              memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)
5                      crt_buf[i] = 0x0700 | ' ';
6              crt_pos -= CRT_COLS;
7      }
</pre>
    </li>

    <li>For the following questions you might wish to consult 
    <a href="http://www.sco.com/developers/devspecs/abi386-4.pdf">
	    System V Application Binary Interface for Intel i386 architecture</a>,
    Section 3.9 "Function Calling Sequence", or its brief version on	
    <a href="http://wiki.osdev.org/Calling_Conventions"> 
	    OSDev Calling Conventions</a>.

      <p>Trace the execution of the following code step-by-step:</p>
      <pre>
int x = 1, y = 3, z = 4;
cprintf("x %d, y %x, z %d\n", x, y, z);
</pre>

      <ul>
        <li>In the call to <code>cprintf()</code>, to what does
        <code>fmt</code> point? To what does <code>ap</code>
        point?</li>

        <li>List (in order of execution) each call to
        <code>cons_putc</code>, <code>va_arg</code>, and
        <code>vcprintf</code>. For <code>cons_putc</code>, list its
        argument as well. For <code>va_arg</code>, list what
        <code>ap</code> points to before and after the call. For
        <code>vcprintf</code> list the values of its two
        arguments.</li>
      </ul>
    </li>

    <li>Run the following code.
      <pre>
    unsigned int i = 0x00646c72;
    cprintf("H%x Wo%s", 57616, &amp;i);
</pre>What is the output? Explain how this output is arrived at in
the step-by-step manner of the previous exercise. <a href=
"http://web.cs.mun.ca/~michael/c/ascii-table.html">Here's an ASCII
table</a> that maps bytes to characters.

      <p>The output depends on that fact that the x86 is
      little-endian. If the x86 were instead big-endian what would
      you set <code>i</code> to in order to yield the same output?
      Would you need to change <code>57616</code> to a different
      value?</p>

      <p><a href=
      "http://www.webopedia.com/TERM/b/big_endian.html">Here's a
      description of little- and big-endian</a> and <a href=
      "http://www.networksorcery.com/enp/ien/ien137.txt">a more
      whimsical description</a>.</p>
    </li>

    <li>In the following code, what is going to be printed after
    <code>'y='</code>? (note: the answer is not a specific value.)
    Why does this happen?
      <pre>
    cprintf("x=%d y=%d", 3);
</pre>
    </li>

    <li>Let's say that GCC changed its calling convention so that it
    pushed arguments on the stack in declaration order, so that the
    last argument is pushed last. How would you have to change
    <code>cprintf</code> or its interface so that it would still be
    possible to pass it a variable number of arguments?</li>
  </ol>

  <div class="challenge">
    <p><span class="header">Challenge</span> Enhance the console to
    allow text to be printed in different colors. The traditional way
    to do this is to make it interpret <a href=
    "http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/">ANSI escape
    sequences</a> embedded in the text strings printed to the
    console, but you may use any mechanism you like. There is plenty
    of information on <a href="../../reference.html">the course
    reference page</a> and elsewhere on the web on programming the
    VGA display hardware. If you're feeling really adventurous, you
    could try switching the VGA hardware into a graphics mode and
    making the console draw text onto the graphical frame buffer.</p>
  </div>

  <h3>The Stack</h3>

  <p>In the final exercise of this lab, we will explore in more
  detail the way the C language uses the stack on the x86, and in the
  process write a useful new kernel monitor function that prints a
  <em>backtrace</em> of the stack: a list of the saved Instruction
  Pointer (IP) values from the nested <samp>call</samp> instructions
  that led to the current point of execution.</p>

  <div class="required">
    <p><span class="header">Exercise 9.</span> Determine where the
    kernel initializes its stack, and exactly where in memory its
    stack is located. How does the kernel reserve space for its
    stack? And at which "end" of this reserved area is the stack
    pointer initialized to point to?</p>
  </div>

  <p>The x86 stack pointer (<samp>esp</samp> register) points to the
  lowest location on the stack that is currently in use. Everything
  <em>below</em> that location in the region reserved for the stack
  is free. Pushing a value onto the stack involves decreasing the
  stack pointer and then writing the value to the place the stack
  pointer points to. Popping a value from the stack involves reading
  the value the stack pointer points to and then increasing the stack
  pointer. In 32-bit mode, the stack can only hold 32-bit values, and
  esp is always divisible by four. Various x86 instructions, such as
  <samp>call</samp>, are "hard-wired" to use the stack pointer
  register.</p>

  <p>The <samp>ebp</samp> (base pointer) register, in contrast, is
  associated with the stack primarily by software convention. On
  entry to a C function, the function's <em>prologue</em> code
  normally saves the previous function's base pointer by pushing it
  onto the stack, and then copies the current <samp>esp</samp> value
  into <samp>ebp</samp> for the duration of the function. If all the
  functions in a program obey this convention, then at any given
  point during the program's execution, it is possible to trace back
  through the stack by following the chain of saved <samp>ebp</samp>
  pointers and determining exactly what nested sequence of function
  calls caused this particular point in the program to be reached.
  This capability can be particularly useful, for example, when a
  particular function causes an <samp>assert</samp> failure or
  <samp>panic</samp> because bad arguments were passed to it, but you
  aren't sure <em>who</em> passed the bad arguments. A stack
  backtrace lets you find the offending function.</p>

  <div class="required">
    <p><span class="header">Exercise 10.</span> To become familiar
    with the C calling conventions on the x86, find the address of
    the <code>test_backtrace</code> function in
    <samp>obj/kern/kernel.asm</samp>, set a breakpoint there, and
    examine what happens each time it gets called after the kernel
    starts. How many 32-bit words does each recursive nesting level
    of <code>test_backtrace</code> push on the stack, and what are
    those words?</p>
  </div>

  <p>The above exercise should give you the information you need to
  implement a stack backtrace function, which you should call
  <code>mon_backtrace()</code>. A prototype for this function is
  already waiting for you in <samp>kern/monitor.c</samp>. You can do
  it entirely in C, but you may find the <code>read_ebp()</code>
  function in <samp>inc/x86.h</samp> useful. You'll also have to hook
  this new function into the kernel monitor's command list so that it
  can be invoked interactively by the user.</p>

  <p>The backtrace function should display a listing of function call
  frames in the following format:</p>
  <pre>
Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
</pre>

  <p>The first line printed reflects the <em>currently executing</em>
  function, namely <code>mon_backtrace</code> itself, the second line
  reflects the function that called <code>mon_backtrace</code>, the
  third line reflects the function that called that one, and so on.
  You should print <em>all</em> the outstanding stack frames. By
  studying <samp>kern/entry.S</samp> you'll find that there is an
  easy way to tell when to stop.</p>

  <p>Within each line, the <samp>ebp</samp> value indicates the base
  pointer into the stack used by that function: i.e., the position of
  the stack pointer just after the function was entered and the
  function prologue code set up the base pointer. The listed
  <samp>eip</samp> value is the function's <em>return instruction
  pointer</em>: the instruction address to which control will return
  when the function returns. The return instruction pointer typically
  points to the instruction after the <samp>call</samp> instruction
  (why?). Finally, the five hex values listed after <samp>args</samp>
  are the first five arguments to the function in question, which
  would have been pushed on the stack just before the function was
  called. If the function was called with fewer than five arguments,
  of course, then not all five of these values will be useful. (Why
  can't the backtrace code detect how many arguments there actually
  are? How could this limitation be fixed?)</p>

  <p>Here are a few specific points you read about in K&amp;R Chapter
  5 that are worth remembering for the following exercise and for
  future labs.</p>

  <ul>
    <li>If <code>int *p = (int*)100</code>, then <code>(int)p +
    1</code> and <code>(int)(p + 1)</code> are different numbers: the
    first is <code>101</code> but the second is <code>104</code>.
    When adding an integer to a pointer, as in the second case, the
    integer is implicitly multiplied by the size of the object the
    pointer points to.</li>

    <li><code>p[i]</code> is defined to be the same as
    <code>*(p+i)</code>, referring to the i'th object in the memory
    pointed to by p. The above rule for addition helps this
    definition work when the objects are larger than one byte.</li>

    <li><code>&amp;p[i]</code> is the same as <code>(p+i)</code>,
    yielding the address of the i'th object in the memory pointed to
    by p.</li>
  </ul>

  <p>Although most C programs never need to cast between pointers and
  integers, operating systems frequently do. Whenever you see an
  addition involving a memory address, ask yourself whether it is an
  integer addition or pointer addition and make sure the value being
  added is appropriately multiplied or not.</p>

  <div class="required">
    <p><span class="header">Exercise 11.</span> Implement the
    backtrace function as specified above. Use the same format as in
    the example, since otherwise the grading script will be confused.
    When you think you have it working right, run <kbd>make
    grade</kbd> to see if its output conforms to what our grading
    script expects, and fix it if it doesn't. <em>After</em> you have
    handed in your Lab 1 code, you are welcome to change the output
    format of the backtrace function any way you like.</p>
  </div>

  <p>At this point, your backtrace function should give you the
  addresses of the function callers on the stack that lead to
  <code>mon_backtrace()</code> being executed. However, in practice
  you often want to know the function names corresponding to those
  addresses. For instance, you may want to know which functions could
  contain a bug that's causing your kernel to crash.</p>

  <p>To help you implement this functionality, we have provided the
  function <code>debuginfo_eip()</code>, which looks up
  <samp>eip</samp> in the symbol table and returns the debugging
  information for that address. This function is defined in
  <samp>kern/kdebug.c</samp>.</p>

  <div class="required">
    <p><span class="header">Exercise 12.</span> Modify your stack
    backtrace function to display, for each <samp>eip</samp>, the
    function name, source file name, and line number corresponding to
    that <samp>eip</samp>.</p>

    <p>In <code>debuginfo_eip</code>, where do <samp>__STAB_*</samp>
    come from? This question has a long answer; to help you to
    discover the answer, here are some things you might want to
    do:</p>

    <ul>
      <li>look in the file <samp>kern/kernel.ld</samp> for
      <samp>__STAB_*</samp></li>

      <li>run <kbd>i386-jos-elf-objdump -h obj/kern/kernel</kbd></li>

      <li>run <kbd>i386-jos-elf-objdump -G obj/kern/kernel</kbd></li>

      <li>run <kbd>i386-jos-elf-gcc -pipe -nostdinc -O2 -fno-builtin
      -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S
      kern/init.c</kbd>, and look at init.s.</li>

      <li>see if the bootloader loads the symbol table in memory as
      part of loading the kernel binary</li>
    </ul>

    <p>Complete the implementation of <code>debuginfo_eip</code> by
    inserting the call to <code>stab_binsearch</code> to find the
    line number for an address.</p>

    <p>Add a <samp>backtrace</samp> command to the kernel monitor,
    and extend your implementation of <code>mon_backtrace</code> to
    call <code>debuginfo_eip</code> and print a line for each stack
    frame of the form:</p>
    <pre>
K&gt; backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: &lt;unknown&gt;+0
K&gt; 
</pre>

    <p>Each line gives the file name and line within that file of the
    stack frame's <samp>eip</samp>, followed by the name of the
    function and the offset of the <samp>eip</samp> from the first
    instruction of the function (e.g., <samp>monitor+106</samp> means
    the return <samp>eip</samp> is 106 bytes past the beginning of
    <samp>monitor</samp>).</p>

    <p>Be sure to print the file and function names on a separate
    line, to avoid confusing the grading script.</p>

    <p>Tip: printf format strings provide an easy, albeit obscure,
    way to print non-null-terminated strings like those in STABS
    tables. <code>printf("%.*s", length, string)</code> prints at
    most <code>length</code> characters of <code>string</code>. Take
    a look at the printf man page to find out why this works.</p>

    <p>You may find that some functions are missing from the
    backtrace. For example, you will probably see a call to
    <code>monitor()</code> but not to <code>runcmd()</code>. This is
    because the compiler in-lines some function calls. Other
    optimizations may cause you to see unexpected line numbers. If
    you get rid of the <samp>-O2</samp> from
    <samp>GNUMakefile</samp>, the backtraces may make more sense (but
    your kernel will run more slowly).</p>
  </div>

  <p><strong>This completes the lab.</strong> In the <samp>lab</samp>
  directory, commit your changes with <kbd>git commit</kbd> and type
  <kbd>make handin</kbd> to submit your code.</p>
</body>
</html>
